{"ast":null,"code":"'use strict';\n\nvar utils = require('./utils');\n\nvar polyfills = require('./polyfills'); // whether is Electron\n\n\nvar isElectron = utils.isElectron(); // whether is NW.js (Node-webkit)\n\nvar isNW = utils.isNW(); // whether is Browser\n\nvar isBrowser = utils.isBrowser(); // whether support canvas\n\nvar isSupportCanvas = isBrowser || isElectron || isNW; // constructor\n\nfunction ImageClipper(options) {\n  options = options || {}; // instance properties\n\n  this.options = {}; // extend instance properties with global defaults and initial properties\n\n  utils.extend(this.options, this.defaults, options); // the quality number requires special handling,\n  // to ensure that the number will always be between 'min' and 'max'\n\n  this.quality(this.options.quality);\n  return this;\n}\n\nImageClipper.prototype.defaults = {\n  canvas: null,\n  // compression level, default: 92\n  quality: 92,\n  maxQuality: 100,\n  minQuality: 1,\n  // output buffer size in bytes for JPEG while using node-canvas\n  bufsize: 4096\n};\n/**\n * load image from the memory.\n *\n * @param {Object} source, anything ctx.drawImage() accepts, usually HTMLImageElement\n * @return ImageClipper instance\n * */\n\nImageClipper.prototype.loadImageFromMemory = function (source) {\n  var options = this.options;\n  source = source || this.originalImage;\n  var width = source.width;\n  var height = source.height;\n\n  var canvas = this.__createCanvas(width, height);\n\n  var ctx = canvas.getContext('2d');\n  ctx.drawImage(source, 0, 0, width, height);\n  this.canvas = canvas;\n  options.imageFormat = options.imageFormat || utils.getImageFormat(source.src);\n\n  if (!this.originalImage) {\n    this.originalImage = source;\n  }\n\n  return this;\n};\n/**\n * Load image from the given path.\n *\n * @param {String} path, the path where the source image\n * @param {Function} callback, to be executed when loading is complete\n * */\n\n\nImageClipper.prototype.loadImageFromUrl = function (path, callback) {\n  var self = this;\n  var options = this.options;\n\n  var image = this.__createImage();\n\n  options.imageFormat = options.imageFormat || utils.getImageFormat(path);\n\n  image.onload = function () {\n    self.loadImageFromMemory(image);\n    callback.call(self);\n  };\n\n  image.src = path;\n};\n/**\n * Load image through loadImageFromUrl or loadImageFromMemory.\n *\n * @param {String | Image} source, the path where the source image\n * @param {Function} callback, to be executed when loading is complete\n * */\n\n\nImageClipper.prototype.image = function (source, callback) {\n  var options = this.options;\n  var sourceType = utils.type(source);\n\n  if (sourceType !== 'String' && sourceType !== 'Image' && sourceType !== 'HTMLImageElement') {\n    throw new Error('invalid arguments');\n  } // imageClipper('path/to/image.jpg')\n\n\n  if (sourceType === 'String') {\n    if (!callback) {\n      throw new Error('callback must be specified when load from path');\n    }\n\n    options.imageFormat = options.imageFormat || utils.getImageFormat(source);\n    this.loadImageFromUrl(source, function () {\n      callback.call(this);\n    });\n  } // imageClipper(Canvas.Image) or imageClipper(new Image),\n  // Object.prototype.toString.call(Canvas.Image) on the server-side Node.js will return '[Object Image]',\n  // Object.prototype.toString.call(new Image) in Browser will return '[Object HTMLImageElement]'\n  else if (sourceType === 'Image' || sourceType === 'HTMLImageElement') {\n    options.imageFormat = options.imageFormat || utils.getImageFormat(source.src);\n    this.loadImageFromMemory(source);\n\n    if (callback && utils.type(callback) === 'Function') {\n      callback.call(this);\n      console.warn('No need to specify callback when load from memory, please use chain-capable method directly like this: clipper(Image).crop(...).resize(...)');\n    }\n\n    return this;\n  }\n};\n/**\n * Crops the resultant image to the given width and height at the given x and y position.\n *\n * @param {Number} x, The x axis of the coordinate for the rectangle starting point\n * @param {Number} y, The y axis of the coordinate for the rectangle starting point\n * @param {Number} width, The rectangle's width\n * @param {Number} height, The rectangle's height\n * @return ImageClipper instance\n * */\n\n\nImageClipper.prototype.crop = function (x, y, width, height) {\n  var canvas = this.canvas;\n  var ctx = canvas.getContext('2d'); // Get cropped pixel data\n\n  var imageData = ctx.getImageData(x, y, width, height); // Create a temporary canvas to place cropped pixel data\n\n  var tempcanvas = this.__createCanvas(width, height);\n\n  var tempctx = tempcanvas.getContext('2d');\n  tempctx.rect(0, 0, width, height);\n  tempctx.fillStyle = 'white';\n  tempctx.fill();\n  tempctx.putImageData(imageData, 0, 0); // change context canvas\n\n  this.canvas = tempcanvas;\n  return this;\n};\n/**\n * Write the resultant image to file.\n *\n * Note: in the Browser (not contain Electron & NW.js),\n * this method is equivalent to toDataURL, callback will still be executed.\n *\n * @param {String} the path where the resultant image will be saved\n * @param {Function} a function to be executed when saving is complete\n * */\n\n\nImageClipper.prototype.toFile = function (path, callback) {\n  var self = this;\n  var options = this.options;\n  var imageFormat = options.imageFormat;\n  this.toDataURL(function (dataUrl) {\n    // return data URI while using in browser\n    if (isBrowser) {\n      callback.call(self, dataUrl);\n    } // Electron & NW.js & server-side Node.js\n    else {\n      this.dataUrlToFile(path, dataUrl, imageFormat, function () {\n        callback.call(self);\n      });\n    }\n  });\n  return this;\n};\n\nImageClipper.prototype.dataUrlToFile = function (path, dataUrl, imageFormat, callback) {\n  var self = this;\n  var base64 = dataUrl.replace('data:' + imageFormat + ';base64,', '');\n  var dataBuffer = new Buffer(base64, 'base64'); // create image binary file\n\n  polyfills.writeFile(path, dataBuffer, function () {\n    callback.call(self);\n  });\n};\n/**\n * Resize the resultant image to the given width and height\n *\n * @param {Number} width, Number of pixels wide\n * @param {Number} height, Number of pixels high\n * @return ImageClipper instance\n * */\n\n\nImageClipper.prototype.resize = function (width, height) {\n  var originalCanvas = this.canvas;\n  var scaleX, scaleY;\n\n  if (!arguments.length) {\n    throw new Error('resize() must be specified at least one parameter');\n  } // proportional scale when resize(width)\n\n\n  if (arguments.length === 1) {\n    // resize(null)\n    if (!width) {\n      throw new Error('resize() inappropriate parameter');\n    }\n\n    scaleX = width / originalCanvas.width;\n    height = originalCanvas.height * scaleX;\n  } else {\n    // proportional scale when resize(null, height)\n    if (!width && height) {\n      scaleY = height / originalCanvas.height;\n      width = originalCanvas.width * scaleY;\n    }\n  }\n\n  var canvas = this.__createCanvas(width, height);\n\n  var ctx = canvas.getContext('2d');\n  ctx.drawImage(originalCanvas, 0, 0, width, height); // change context canvas\n\n  this.canvas = canvas;\n  return this;\n};\n/**\n * Removes rectangular pixels from the given width and height at the given x and y position.\n *\n * @param {Number} x, The x axis of the coordinate for the rectangle starting point\n * @param {Number} y, The y axis of the coordinate for the rectangle starting point\n * @param {Number} width, Number of pixels wide will be removed\n * @param {Number} height, Number of pixels high will be removed\n * @return ImageClipper instance\n * */\n\n\nImageClipper.prototype.clear = function (x, y, width, height) {\n  var canvas = this.canvas; // get target canvas's context\n\n  var ctx = canvas.getContext('2d'); // clear rect pixel\n\n  ctx.clearRect(x, y, width, height); // fill the cleared area with a white background\n\n  ctx.fillStyle = '#fff';\n  ctx.fillRect(x, y, width, height);\n  return this;\n};\n/**\n * Adjusts the jpeg and webp compression level.\n *\n * @param {Number | String} level, a Number between 1 and 100 indicating image quality\n * @return ImageClipper instance\n * */\n\n\nImageClipper.prototype.quality = function (level) {\n  if (utils.type(level) !== 'Number' && utils.type(level) !== 'String') {\n    throw new Error('Invalid arguments');\n  }\n\n  if (!level) {\n    return this;\n  }\n\n  var options = this.options;\n  level = parseFloat(level); // this will always be between 'min' and 'max'\n\n  level = utils.rangeNumber(level, options.minQuality, options.maxQuality);\n  options.quality = level;\n  return this;\n};\n/**\n * Return a string containing the data URI of current resultant canvas.\n *\n * @param {Number} quality\n * @param {Function} callback, optional in the Browser & Electron & NW.js, neccessary on the server-side Node.js\n * @return ImageClipper instance\n * */\n\n\nImageClipper.prototype.toDataURL = function (quality, callback) {\n  var self = this;\n  var options = this.options;\n  var qualityLevel = options.quality;\n  var minQuality = options.minQuality;\n  var maxQuality = options.maxQuality;\n  var imageFormat = options.imageFormat;\n  var bufsize = options.bufsize; // toDataURL('68', function() {...})\n\n  if (typeof quality === 'string') {\n    quality = parseFloat(quality);\n  } // toDataURL()\n\n\n  if (arguments.length === 0) {\n    quality = qualityLevel;\n  } else if (arguments.length === 1) {\n    // toDataURL(quality)\n    if (typeof quality === 'number') {\n      quality = utils.rangeNumber(quality, minQuality, maxQuality);\n    } // toDataURL(callback)\n    else if (typeof quality === 'function') {\n      callback = quality;\n      quality = qualityLevel;\n    }\n  } // toDataURL(quality, callback)\n  else if (arguments.length === 2) {\n    quality = utils.rangeNumber(quality, minQuality, maxQuality);\n  }\n\n  var canvas = this.canvas; // Browsers & Electron & NW.js\n\n  if (isSupportCanvas) {\n    var dataUrl = canvas.toDataURL(imageFormat, quality / 100);\n    callback && callback.call(this, dataUrl);\n    return dataUrl;\n  } // server-side Node.js\n  else {\n    if (!callback) {\n      throw new Error('toDataURL(): callback must be specified');\n    }\n\n    polyfills.toDataURL({\n      canvas: canvas,\n      imageFormat: imageFormat,\n      quality: quality,\n      bufsize: bufsize\n    }, function (dataUrl) {\n      callback.call(self, dataUrl);\n    });\n  }\n\n  return this;\n};\n/**\n * configure instance properties\n * this will override the global settings\n *\n * support both configure(name, value) and configure({name: value})\n * @param {String | Object} name, property name or properties list\n * @param {String | Undefined} value, property value or nothing\n * */\n\n\nImageClipper.prototype.configure = function (name, value) {\n  var options = this.options;\n  utils.setter(options, name, value); // the quality number requires special handling,\n  // to ensure that the number will always be between 'min' and 'max'\n\n  if (options.quality) {\n    this.quality(options.quality);\n  }\n\n  return this;\n}; // get canvas\n\n\nImageClipper.prototype.getCanvas = function () {\n  return this.canvas;\n}; // destroy canvas\n\n\nImageClipper.prototype.destroy = function () {\n  this.canvas = null;\n  return this;\n}; // reset canvas\n\n\nImageClipper.prototype.reset = function () {\n  return this.destroy().loadImageFromMemory();\n}; // inject canvas implementation library\n// tiis will override the global settings\n\n\nImageClipper.prototype.injectNodeCanvas = function (canvas) {\n  if (typeof canvas !== 'undefined') {\n    this.options.canvas = canvas;\n  }\n}; // create Canvas object\n\n\nImageClipper.prototype.__createCanvas = function (width, height) {\n  var c;\n\n  if (isSupportCanvas) {\n    var document = window.document;\n    c = document.createElement('canvas');\n    c.width = width;\n    c.height = height;\n  } else {\n    // Node.js\n    var canvas = this.options.canvas;\n\n    if (canvas && canvas.createCanvas) {\n      c = canvas.createCanvas(width, height);\n    } else {\n      throw new Error('Require node-canvas on the server-side Node.js');\n    }\n  }\n\n  return c;\n}; // create Image object\n\n\nImageClipper.prototype.__createImage = function () {\n  var Image, img;\n\n  if (isSupportCanvas) {\n    Image = window.Image;\n  } else {\n    // Node.js\n    var canvas = this.options.canvas;\n\n    if (canvas && canvas.Image) {\n      Image = canvas.Image;\n    } else {\n      throw new Error('Require node-canvas on the server-side Node.js');\n    }\n  }\n\n  img = new Image();\n  return img;\n};\n/**\n * configure global default properties\n * properties changed in this object (same properties configurable through the constructor)\n * will take effect for every instance created after the change\n *\n * support both configure(name, value) and configure({name: value})\n * @param {String | Object} name, property name or properties list\n * @param {String | Undefined} value, property value or nothing\n * */\n\n\nImageClipper.__configure = function (name, value) {\n  var defaults = ImageClipper.prototype.defaults;\n  utils.setter(defaults, name, value); // the quality number requires special handling,\n  // to ensure that the number will always be between 'min' and 'max'\n\n  if (defaults.quality) {\n    defaults.quality = utils.rangeNumber(defaults.quality, defaults.minQuality, defaults.maxQuality);\n  }\n};\n\nmodule.exports = ImageClipper;","map":{"version":3,"names":["utils","require","polyfills","isElectron","isNW","isBrowser","isSupportCanvas","ImageClipper","options","extend","defaults","quality","prototype","canvas","maxQuality","minQuality","bufsize","loadImageFromMemory","source","originalImage","width","height","__createCanvas","ctx","getContext","drawImage","imageFormat","getImageFormat","src","loadImageFromUrl","path","callback","self","image","__createImage","onload","call","sourceType","type","Error","console","warn","crop","x","y","imageData","getImageData","tempcanvas","tempctx","rect","fillStyle","fill","putImageData","toFile","toDataURL","dataUrl","dataUrlToFile","base64","replace","dataBuffer","Buffer","writeFile","resize","originalCanvas","scaleX","scaleY","arguments","length","clear","clearRect","fillRect","level","parseFloat","rangeNumber","qualityLevel","configure","name","value","setter","getCanvas","destroy","reset","injectNodeCanvas","c","document","window","createElement","createCanvas","Image","img","__configure","module","exports"],"sources":["E:/Sites/virusv4/Client/node_modules/image-clipper/lib/clipper.js"],"sourcesContent":["'use strict'\n\nvar utils = require('./utils')\nvar polyfills = require('./polyfills')\n\n// whether is Electron\nvar isElectron = utils.isElectron()\n\n// whether is NW.js (Node-webkit)\nvar isNW = utils.isNW()\n\n// whether is Browser\nvar isBrowser = utils.isBrowser()\n\n// whether support canvas\nvar isSupportCanvas = isBrowser || isElectron || isNW\n\n// constructor\nfunction ImageClipper(options) {\n  options = options || {}\n\n  // instance properties\n  this.options = {}\n\n  // extend instance properties with global defaults and initial properties\n  utils.extend(this.options, this.defaults, options)\n\n  // the quality number requires special handling,\n  // to ensure that the number will always be between 'min' and 'max'\n  this.quality(this.options.quality)\n\n  return this\n}\n\nImageClipper.prototype.defaults = {\n  canvas: null,\n  // compression level, default: 92\n  quality: 92,\n  maxQuality: 100,\n  minQuality: 1,\n  // output buffer size in bytes for JPEG while using node-canvas\n  bufsize: 4096\n}\n\n/**\n * load image from the memory.\n *\n * @param {Object} source, anything ctx.drawImage() accepts, usually HTMLImageElement\n * @return ImageClipper instance\n * */\nImageClipper.prototype.loadImageFromMemory = function(source) {\n  var options = this.options\n\n  source = source || this.originalImage\n\n  var width = source.width\n  var height = source.height\n\n  var canvas = this.__createCanvas(width, height)\n  var ctx = canvas.getContext('2d')\n\n  ctx.drawImage(source, 0, 0, width, height)\n\n  this.canvas = canvas\n  options.imageFormat = options.imageFormat || utils.getImageFormat(source.src)\n\n  if (!this.originalImage) {\n    this.originalImage = source\n  }\n\n  return this\n}\n\n/**\n * Load image from the given path.\n *\n * @param {String} path, the path where the source image\n * @param {Function} callback, to be executed when loading is complete\n * */\nImageClipper.prototype.loadImageFromUrl = function(path, callback) {\n  var self = this\n  var options = this.options\n  var image = this.__createImage()\n\n  options.imageFormat = options.imageFormat || utils.getImageFormat(path)\n\n  image.onload = function() {\n    self.loadImageFromMemory(image)\n    callback.call(self)\n  }\n\n  image.src = path\n}\n\n/**\n * Load image through loadImageFromUrl or loadImageFromMemory.\n *\n * @param {String | Image} source, the path where the source image\n * @param {Function} callback, to be executed when loading is complete\n * */\nImageClipper.prototype.image = function(source, callback) {\n  var options = this.options\n\n  var sourceType = utils.type(source)\n\n  if (sourceType !== 'String' &&\n      sourceType !== 'Image' &&\n      sourceType !== 'HTMLImageElement') {\n    throw new Error('invalid arguments')\n  }\n\n  // imageClipper('path/to/image.jpg')\n  if (sourceType === 'String') {\n    if (!callback) {\n      throw new Error('callback must be specified when load from path')\n    }\n\n    options.imageFormat = options.imageFormat || utils.getImageFormat(source)\n\n    this.loadImageFromUrl(source, function() {\n      callback.call(this)\n    })\n  }\n  // imageClipper(Canvas.Image) or imageClipper(new Image),\n  // Object.prototype.toString.call(Canvas.Image) on the server-side Node.js will return '[Object Image]',\n  // Object.prototype.toString.call(new Image) in Browser will return '[Object HTMLImageElement]'\n  else if (sourceType === 'Image' || sourceType === 'HTMLImageElement') {\n    options.imageFormat = options.imageFormat || utils.getImageFormat(source.src)\n\n    this.loadImageFromMemory(source)\n\n    if (callback && utils.type(callback) === 'Function') {\n      callback.call(this)\n      console.warn('No need to specify callback when load from memory, please use chain-capable method directly like this: clipper(Image).crop(...).resize(...)')\n    }\n\n    return this\n  }\n}\n\n/**\n * Crops the resultant image to the given width and height at the given x and y position.\n *\n * @param {Number} x, The x axis of the coordinate for the rectangle starting point\n * @param {Number} y, The y axis of the coordinate for the rectangle starting point\n * @param {Number} width, The rectangle's width\n * @param {Number} height, The rectangle's height\n * @return ImageClipper instance\n * */\nImageClipper.prototype.crop = function(x, y, width, height) {\n  var canvas = this.canvas\n  var ctx = canvas.getContext('2d')\n\n  // Get cropped pixel data\n  var imageData = ctx.getImageData(x, y, width, height)\n\n  // Create a temporary canvas to place cropped pixel data\n  var tempcanvas = this.__createCanvas(width, height)\n  var tempctx = tempcanvas.getContext('2d')\n\n  tempctx.rect(0, 0, width, height)\n  tempctx.fillStyle = 'white'\n  tempctx.fill()\n  tempctx.putImageData(imageData, 0, 0)\n\n  // change context canvas\n  this.canvas = tempcanvas\n\n  return this\n}\n\n/**\n * Write the resultant image to file.\n *\n * Note: in the Browser (not contain Electron & NW.js),\n * this method is equivalent to toDataURL, callback will still be executed.\n *\n * @param {String} the path where the resultant image will be saved\n * @param {Function} a function to be executed when saving is complete\n * */\nImageClipper.prototype.toFile = function(path, callback) {\n  var self = this\n  var options = this.options\n  var imageFormat = options.imageFormat\n\n  this.toDataURL(function(dataUrl) {\n    // return data URI while using in browser\n    if (isBrowser) {\n      callback.call(self, dataUrl)\n    }\n    // Electron & NW.js & server-side Node.js\n    else {\n      this.dataUrlToFile(path, dataUrl, imageFormat, function() {\n        callback.call(self)\n      })\n    }\n  })\n\n  return this\n}\n\nImageClipper.prototype.dataUrlToFile = function(path, dataUrl, imageFormat, callback) {\n  var self = this\n  var base64 = dataUrl.replace('data:' + imageFormat + ';base64,', '')\n\n  var dataBuffer = new Buffer(base64, 'base64')\n\n  // create image binary file\n  polyfills.writeFile(path, dataBuffer, function() {\n    callback.call(self)\n  })\n}\n\n/**\n * Resize the resultant image to the given width and height\n *\n * @param {Number} width, Number of pixels wide\n * @param {Number} height, Number of pixels high\n * @return ImageClipper instance\n * */\nImageClipper.prototype.resize = function(width, height) {\n  var originalCanvas = this.canvas\n  var scaleX, scaleY\n\n  if (!arguments.length) {\n    throw new Error('resize() must be specified at least one parameter')\n  }\n\n  // proportional scale when resize(width)\n  if (arguments.length === 1) {\n    // resize(null)\n    if (!width) {\n      throw new Error('resize() inappropriate parameter')\n    }\n\n    scaleX = width / originalCanvas.width\n    height = originalCanvas.height * scaleX\n  } else {\n    // proportional scale when resize(null, height)\n    if (!width && height) {\n      scaleY = height / originalCanvas.height\n      width = originalCanvas.width * scaleY\n    }\n  }\n\n  var canvas = this.__createCanvas(width, height)\n  var ctx = canvas.getContext('2d')\n\n  ctx.drawImage(originalCanvas, 0, 0, width, height)\n\n  // change context canvas\n  this.canvas = canvas\n\n  return this\n}\n\n/**\n * Removes rectangular pixels from the given width and height at the given x and y position.\n *\n * @param {Number} x, The x axis of the coordinate for the rectangle starting point\n * @param {Number} y, The y axis of the coordinate for the rectangle starting point\n * @param {Number} width, Number of pixels wide will be removed\n * @param {Number} height, Number of pixels high will be removed\n * @return ImageClipper instance\n * */\nImageClipper.prototype.clear = function(x, y, width, height) {\n  var canvas = this.canvas\n  // get target canvas's context\n  var ctx = canvas.getContext('2d')\n\n  // clear rect pixel\n  ctx.clearRect(x, y, width, height)\n\n  // fill the cleared area with a white background\n  ctx.fillStyle = '#fff'\n  ctx.fillRect(x, y, width, height)\n\n  return this\n}\n\n/**\n * Adjusts the jpeg and webp compression level.\n *\n * @param {Number | String} level, a Number between 1 and 100 indicating image quality\n * @return ImageClipper instance\n * */\nImageClipper.prototype.quality = function(level) {\n  if (utils.type(level) !== 'Number' && utils.type(level) !== 'String') {\n    throw new Error('Invalid arguments')\n  }\n\n  if (!level) {\n    return this\n  }\n\n  var options = this.options\n\n  level = parseFloat(level)\n\n  // this will always be between 'min' and 'max'\n  level = utils.rangeNumber(level, options.minQuality, options.maxQuality)\n\n  options.quality = level\n\n  return this\n}\n\n/**\n * Return a string containing the data URI of current resultant canvas.\n *\n * @param {Number} quality\n * @param {Function} callback, optional in the Browser & Electron & NW.js, neccessary on the server-side Node.js\n * @return ImageClipper instance\n * */\nImageClipper.prototype.toDataURL = function(quality, callback) {\n  var self = this\n  var options = this.options\n  var qualityLevel = options.quality\n  var minQuality = options.minQuality\n  var maxQuality = options.maxQuality\n  var imageFormat = options.imageFormat\n  var bufsize = options.bufsize\n\n  // toDataURL('68', function() {...})\n  if (typeof quality === 'string') {\n    quality = parseFloat(quality)\n  }\n\n  // toDataURL()\n  if (arguments.length === 0) {\n    quality = qualityLevel\n  }\n  else if (arguments.length === 1) {\n    // toDataURL(quality)\n    if (typeof quality === 'number') {\n      quality = utils.rangeNumber(quality, minQuality, maxQuality)\n    }\n    // toDataURL(callback)\n    else if (typeof quality === 'function') {\n      callback = quality\n      quality = qualityLevel\n    }\n  }\n  // toDataURL(quality, callback)\n  else if (arguments.length === 2) {\n    quality = utils.rangeNumber(quality, minQuality, maxQuality)\n  }\n\n  var canvas = this.canvas\n\n  // Browsers & Electron & NW.js\n  if (isSupportCanvas) {\n    var dataUrl = canvas.toDataURL(imageFormat, quality / 100)\n    callback && callback.call(this, dataUrl)\n    return dataUrl\n  }\n  // server-side Node.js\n  else {\n    if (!callback) {\n      throw new Error('toDataURL(): callback must be specified')\n    }\n\n    polyfills.toDataURL({\n      canvas: canvas,\n      imageFormat: imageFormat,\n      quality: quality,\n      bufsize: bufsize\n    }, function(dataUrl) {\n      callback.call(self, dataUrl)\n    })\n  }\n\n  return this\n}\n\n/**\n * configure instance properties\n * this will override the global settings\n *\n * support both configure(name, value) and configure({name: value})\n * @param {String | Object} name, property name or properties list\n * @param {String | Undefined} value, property value or nothing\n * */\nImageClipper.prototype.configure = function(name, value) {\n  var options = this.options\n\n  utils.setter(options, name, value)\n\n  // the quality number requires special handling,\n  // to ensure that the number will always be between 'min' and 'max'\n  if (options.quality) {\n    this.quality(options.quality)\n  }\n\n  return this\n}\n\n// get canvas\nImageClipper.prototype.getCanvas = function() {\n  return this.canvas\n}\n\n// destroy canvas\nImageClipper.prototype.destroy = function() {\n  this.canvas = null\n  return this\n}\n\n// reset canvas\nImageClipper.prototype.reset = function() {\n  return this.destroy().loadImageFromMemory()\n}\n\n// inject canvas implementation library\n// tiis will override the global settings\nImageClipper.prototype.injectNodeCanvas = function(canvas) {\n  if (typeof canvas !== 'undefined') {\n    this.options.canvas = canvas\n  }\n}\n\n// create Canvas object\nImageClipper.prototype.__createCanvas = function(width, height) {\n  var c\n\n  if (isSupportCanvas) {\n    var document = window.document\n    c = document.createElement('canvas')\n    c.width = width\n    c.height = height\n  } else {\n    // Node.js\n    var canvas = this.options.canvas\n    if (canvas && canvas.createCanvas) {\n      c = canvas.createCanvas(width, height)\n    } else {\n      throw new Error('Require node-canvas on the server-side Node.js')\n    }\n  }\n\n  return c\n}\n\n// create Image object\nImageClipper.prototype.__createImage = function() {\n  var Image, img\n\n  if (isSupportCanvas) {\n    Image = window.Image\n  } else {\n    // Node.js\n    var canvas = this.options.canvas\n    if (canvas && canvas.Image) {\n      Image = canvas.Image\n    } else {\n      throw new Error('Require node-canvas on the server-side Node.js')\n    }\n  }\n\n  img = new Image\n\n  return img\n}\n\n/**\n * configure global default properties\n * properties changed in this object (same properties configurable through the constructor)\n * will take effect for every instance created after the change\n *\n * support both configure(name, value) and configure({name: value})\n * @param {String | Object} name, property name or properties list\n * @param {String | Undefined} value, property value or nothing\n * */\nImageClipper.__configure = function(name, value) {\n  var defaults = ImageClipper.prototype.defaults\n\n  utils.setter(defaults, name, value)\n\n  // the quality number requires special handling,\n  // to ensure that the number will always be between 'min' and 'max'\n  if (defaults.quality) {\n    defaults.quality = utils.rangeNumber(defaults.quality, defaults.minQuality, defaults.maxQuality)\n  }\n}\n\nmodule.exports = ImageClipper"],"mappings":"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"},"metadata":{},"sourceType":"script"}