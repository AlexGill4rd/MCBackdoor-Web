{"ast":null,"code":"/**\n * @fileoverview Strengthen the ability of file system\n * @author wliao <wliao@Ctrip.com> \n */\nvar fs = require('fs');\n\nvar util = require('utils-extend');\n\nvar path = require('path');\n\nvar fileMatch = require('file-match');\n\nfunction checkCbAndOpts(options, callback) {\n  if (util.isFunction(options)) {\n    return {\n      options: null,\n      callback: options\n    };\n  } else if (util.isObject(options)) {\n    return {\n      options: options,\n      callback: callback\n    };\n  } else {\n    return {\n      options: null,\n      callback: util.noop\n    };\n  }\n}\n\nfunction getExists(filepath) {\n  var exists = fs.existsSync(filepath);\n\n  if (exists) {\n    return filepath;\n  } else {\n    return getExists(path.dirname(filepath));\n  }\n}\n\nutil.extend(exports, fs);\n/**\n * @description\n * Assign node origin methods to fs\n */\n\nexports.fs = fs;\nexports.fileMatch = fileMatch;\n/**\n * @description\n * Create dir, if dir exist, it will only invoke callback.\n *\n * @example\n * ```js\n *   fs.mkdir('1/2/3/4/5', 511);\n *   fs.mkdir('path/2/3', function() {});\n * ```\n */\n\nexports.mkdir = function (filepath, mode, callback) {\n  var root = getExists(filepath);\n  var children = path.relative(root, filepath);\n\n  if (util.isFunction(mode)) {\n    callback = mode;\n    mode = null;\n  }\n\n  if (!util.isFunction(callback)) {\n    callback = util.noop;\n  }\n\n  mode = mode || 511;\n  if (!children) return callback();\n  children = children.split(path.sep);\n\n  function create(filepath) {\n    if (create.count === children.length) {\n      return callback();\n    }\n\n    filepath = path.join(filepath, children[create.count]);\n    fs.mkdir(filepath, mode, function (err) {\n      create.count++;\n      create(filepath);\n    });\n  }\n\n  create.count = 0;\n  create(root);\n};\n/**\n * @description\n * Same as mkdir, but it is synchronous\n */\n\n\nexports.mkdirSync = function (filepath, mode) {\n  var root = getExists(filepath);\n  var children = path.relative(root, filepath);\n  if (!children) return;\n  children = children.split(path.sep);\n  children.forEach(function (item) {\n    root = path.join(root, item);\n    fs.mkdirSync(root, mode);\n  });\n};\n/**\n * @description \n * Create file, if path don't exists, it will not throw error.\n * And will mkdir for path, it is asynchronous\n * \n * @example\n * ```js\n *   fs.writeFile('path/filename.txt', 'something')\n *   fs.writeFile('path/filename.txt', 'something', {})\n * ```\n */\n\n\nexports.writeFile = function (filename, data, options, callback) {\n  var result = checkCbAndOpts(options, callback);\n  var dirname = path.dirname(filename);\n  options = result.options;\n  callback = result.callback; // Create dir first\n\n  exports.mkdir(dirname, function () {\n    fs.writeFile(filename, data, options, callback);\n  });\n};\n/**\n * @description\n * Same as writeFile, but it is synchronous\n */\n\n\nexports.writeFileSync = function (filename, data, options) {\n  var dirname = path.dirname(filename);\n  exports.mkdirSync(dirname);\n  fs.writeFileSync(filename, data, options);\n};\n/**\n * @description\n * Asynchronously copy a file\n * @example\n * file.copyFile('demo.txt', 'demo.dest.txt', { done: function(err) { }})\n */\n\n\nexports.copyFile = function (srcpath, destpath, options) {\n  options = util.extend({\n    encoding: 'utf8',\n    done: util.noop\n  }, options || {});\n\n  if (!options.process) {\n    options.encoding = null;\n  }\n\n  fs.readFile(srcpath, {\n    encoding: options.encoding\n  }, function (err, contents) {\n    if (err) return options.done(err);\n\n    if (options.process) {\n      contents = options.process(contents);\n    }\n\n    exports.writeFile(destpath, contents, options, options.done);\n  });\n};\n/**\n * @description\n * Copy file to dest, if no process options, it will only copy file to dest\n * @example\n * file.copyFileSync('demo.txt', 'demo.dest.txt' { process: function(contents) { }});\n * file.copyFileSync('demo.png', 'dest.png');\n */\n\n\nexports.copyFileSync = function (srcpath, destpath, options) {\n  options = util.extend({\n    encoding: 'utf8'\n  }, options || {});\n  var contents;\n\n  if (options.process) {\n    contents = fs.readFileSync(srcpath, options);\n    contents = options.process(contents, srcpath, options.relative);\n\n    if (util.isObject(contents) && contents.filepath) {\n      destpath = contents.filepath;\n      contents = contents.contents;\n    }\n\n    exports.writeFileSync(destpath, contents, options);\n  } else {\n    contents = fs.readFileSync(srcpath);\n    exports.writeFileSync(destpath, contents);\n  }\n};\n/**\n * @description\n * Recurse into a directory, executing callback for each file and folder\n * if the filename is undefiend, the callback is for folder, otherwise for file.\n * and it is asynchronous\n * @example\n * file.recurse('path', function(filepath, filename) { });\n * file.recurse('path', ['*.js', 'path/**\\/*.html'], function(filepath, relative, filename) { });\n */\n\n\nexports.recurse = function (dirpath, filter, callback) {\n  if (util.isFunction(filter)) {\n    callback = filter;\n    filter = null;\n  }\n\n  var filterCb = fileMatch(filter);\n  var rootpath = dirpath;\n\n  function recurse(dirpath) {\n    fs.readdir(dirpath, function (err, files) {\n      if (err) return callback(err);\n      files.forEach(function (filename) {\n        var filepath = path.join(dirpath, filename);\n        fs.stat(filepath, function (err, stats) {\n          var relative = path.relative(rootpath, filepath);\n          var flag = filterCb(relative);\n\n          if (stats.isDirectory()) {\n            recurse(filepath);\n            if (flag) callback(filepath, relative);\n          } else {\n            if (flag) callback(filepath, relative, filename);\n          }\n        });\n      });\n    });\n  }\n\n  recurse(dirpath);\n};\n/**\n * @description\n * Same as recurse, but it is synchronous\n * @example\n * file.recurseSync('path', function(filepath, filename) {});\n * file.recurseSync('path', ['*.js', 'path/**\\/*.html'], function(filepath, relative, filename) {});\n */\n\n\nexports.recurseSync = function (dirpath, filter, callback) {\n  if (util.isFunction(filter)) {\n    callback = filter;\n    filter = null;\n  }\n\n  var filterCb = fileMatch(filter);\n  var rootpath = dirpath;\n\n  function recurse(dirpath) {\n    fs.readdirSync(dirpath).forEach(function (filename) {\n      var filepath = path.join(dirpath, filename);\n      var stats = fs.statSync(filepath);\n      var relative = path.relative(rootpath, filepath);\n      var flag = filterCb(relative);\n\n      if (stats.isDirectory()) {\n        recurse(filepath);\n        if (flag) callback(filepath, relative);\n      } else {\n        if (flag) callback(filepath, relative, filename);\n      }\n    });\n  }\n\n  recurse(dirpath);\n};\n/**\n * @description\n * Remove folder and files in folder, but it's synchronous\n * @example\n * file.rmdirSync('path');\n */\n\n\nexports.rmdirSync = function (dirpath) {\n  exports.recurseSync(dirpath, function (filepath, relative, filename) {\n    // it is file, otherwise it's folder\n    if (filename) {\n      fs.unlinkSync(filepath);\n    } else {\n      fs.rmdirSync(filepath);\n    }\n  });\n  fs.rmdirSync(dirpath);\n};\n/**\n * @description\n * Copy dirpath to destpath, pass process callback for each file hanlder\n * if you want to change the dest filepath, process callback return { contents: '', filepath: ''}\n * otherwise only change contents\n * @example\n * file.copySync('path', 'dest');\n * file.copySync('src', 'dest/src');\n * file.copySync('path', 'dest', { process: function(contents, filepath) {} });\n * file.copySync('path', 'dest', { process: function(contents, filepath) {} }, noProcess: ['']);\n */\n\n\nexports.copySync = function (dirpath, destpath, options) {\n  options = util.extend({\n    encoding: 'utf8',\n    filter: null,\n    noProcess: ''\n  }, options || {});\n  var noProcessCb = fileMatch(options.noProcess); // Make sure dest root\n\n  exports.mkdirSync(destpath);\n  exports.recurseSync(dirpath, options.filter, function (filepath, relative, filename) {\n    if (!filename) return;\n    var newpath = path.join(destpath, relative);\n    var opts = {\n      relative: relative\n    };\n\n    if (options.process && !noProcessCb(relative)) {\n      opts.encoding = options.encoding;\n      opts.process = options.process;\n    }\n\n    exports.copyFileSync(filepath, newpath, opts);\n  });\n};","map":{"version":3,"names":["fs","require","util","path","fileMatch","checkCbAndOpts","options","callback","isFunction","isObject","noop","getExists","filepath","exists","existsSync","dirname","extend","exports","mkdir","mode","root","children","relative","split","sep","create","count","length","join","err","mkdirSync","forEach","item","writeFile","filename","data","result","writeFileSync","copyFile","srcpath","destpath","encoding","done","process","readFile","contents","copyFileSync","readFileSync","recurse","dirpath","filter","filterCb","rootpath","readdir","files","stat","stats","flag","isDirectory","recurseSync","readdirSync","statSync","rmdirSync","unlinkSync","copySync","noProcess","noProcessCb","newpath","opts"],"sources":["E:/Sites/virusv4/Client/node_modules/file-system/file-system.js"],"sourcesContent":["/**\n * @fileoverview Strengthen the ability of file system\n * @author wliao <wliao@Ctrip.com> \n */\nvar fs = require('fs');\nvar util = require('utils-extend');\nvar path = require('path');\nvar fileMatch = require('file-match');\n\nfunction checkCbAndOpts(options, callback) {\n  if (util.isFunction(options)) {\n    return {\n      options: null,\n      callback: options\n    };\n  } else if (util.isObject(options)) {\n    return {\n      options: options,\n      callback: callback\n    };\n  } else {\n    return {\n      options: null,\n      callback: util.noop\n    };\n  }\n}\n\nfunction getExists(filepath) {\n  var exists = fs.existsSync(filepath);\n\n  if (exists) {\n    return filepath;\n  } else {\n    return getExists(path.dirname(filepath));\n  }\n}\n\nutil.extend(exports, fs);\n\n/**\n * @description\n * Assign node origin methods to fs\n */\nexports.fs = fs;\n\nexports.fileMatch = fileMatch;\n\n/**\n * @description\n * Create dir, if dir exist, it will only invoke callback.\n *\n * @example\n * ```js\n *   fs.mkdir('1/2/3/4/5', 511);\n *   fs.mkdir('path/2/3', function() {});\n * ```\n */\nexports.mkdir = function(filepath, mode, callback) {\n  var root = getExists(filepath);\n  var children  = path.relative(root, filepath);\n\n  if (util.isFunction(mode)) {\n    callback = mode;\n    mode = null;\n  }\n\n  if (!util.isFunction(callback)) {\n    callback = util.noop;\n  }\n\n  mode = mode || 511;\n\n  if (!children) return callback();\n\n  children = children.split(path.sep);\n\n  function create(filepath) {\n    if (create.count === children.length) {\n      return callback();\n    }\n\n    filepath = path.join(filepath, children[create.count]);\n\n    fs.mkdir(filepath, mode, function(err) {\n      create.count++;\n      create(filepath);\n    });\n  }\n\n  create.count = 0;\n  create(root);\n};\n\n/**\n * @description\n * Same as mkdir, but it is synchronous\n */\nexports.mkdirSync = function(filepath, mode) {\n  var root = getExists(filepath);\n  var children  = path.relative(root, filepath);\n\n  if (!children) return;\n\n  children = children.split(path.sep);\n\n  children.forEach(function(item) {\n    root = path.join(root, item);\n    fs.mkdirSync(root, mode);\n  });\n};\n\n/**\n * @description \n * Create file, if path don't exists, it will not throw error.\n * And will mkdir for path, it is asynchronous\n * \n * @example\n * ```js\n *   fs.writeFile('path/filename.txt', 'something')\n *   fs.writeFile('path/filename.txt', 'something', {})\n * ```\n */\nexports.writeFile = function(filename, data, options, callback) {\n  var result = checkCbAndOpts(options, callback);\n  var dirname = path.dirname(filename);\n  options = result.options;\n  callback = result.callback;\n\n  // Create dir first\n  exports.mkdir(dirname, function() {\n    fs.writeFile(filename, data, options, callback);\n  });\n};\n\n/**\n * @description\n * Same as writeFile, but it is synchronous\n */\nexports.writeFileSync = function(filename, data, options) {\n  var dirname = path.dirname(filename);\n\n  exports.mkdirSync(dirname);\n  fs.writeFileSync(filename, data, options);\n};\n\n/**\n * @description\n * Asynchronously copy a file\n * @example\n * file.copyFile('demo.txt', 'demo.dest.txt', { done: function(err) { }})\n */\nexports.copyFile = function(srcpath, destpath, options) {\n  options = util.extend({\n    encoding: 'utf8',\n    done: util.noop\n  }, options || {});\n\n  if (!options.process) {\n    options.encoding = null;\n  }\n\n  fs.readFile(srcpath, {\n    encoding: options.encoding\n  }, function(err, contents) {\n    if (err) return options.done(err);\n\n    if (options.process) {\n      contents = options.process(contents);\n    }\n\n    exports.writeFile(destpath, contents, options, options.done);\n  });\n};\n\n/**\n * @description\n * Copy file to dest, if no process options, it will only copy file to dest\n * @example\n * file.copyFileSync('demo.txt', 'demo.dest.txt' { process: function(contents) { }});\n * file.copyFileSync('demo.png', 'dest.png');\n */\nexports.copyFileSync = function(srcpath, destpath, options) {\n  options = util.extend({\n    encoding: 'utf8' \n  }, options || {});\n  var contents;\n\n  if (options.process) {\n    contents = fs.readFileSync(srcpath, options);\n    contents = options.process(contents, srcpath, options.relative);\n\n    if (util.isObject(contents) && contents.filepath) {\n      destpath = contents.filepath;\n      contents = contents.contents;\n    }\n\n    exports.writeFileSync(destpath, contents, options);    \n  } else {\n    contents = fs.readFileSync(srcpath);\n    exports.writeFileSync(destpath, contents);\n  }\n};\n\n/**\n * @description\n * Recurse into a directory, executing callback for each file and folder\n * if the filename is undefiend, the callback is for folder, otherwise for file.\n * and it is asynchronous\n * @example\n * file.recurse('path', function(filepath, filename) { });\n * file.recurse('path', ['*.js', 'path/**\\/*.html'], function(filepath, relative, filename) { });\n */\nexports.recurse = function(dirpath, filter, callback) {\n  if (util.isFunction(filter)) {\n    callback = filter;\n    filter = null;\n  }\n  var filterCb = fileMatch(filter);\n  var rootpath = dirpath;\n\n  function recurse(dirpath) {\n    fs.readdir(dirpath, function(err, files) {\n      if (err) return callback(err);\n\n      files.forEach(function(filename) {\n        var filepath = path.join(dirpath, filename);\n\n        fs.stat(filepath, function(err, stats) {\n            var relative = path.relative(rootpath, filepath);\n            var flag = filterCb(relative);\n\n            if (stats.isDirectory()) {\n              recurse(filepath);\n              if (flag) callback(filepath, relative);\n            } else {\n              if (flag) callback(filepath, relative, filename);\n            }\n          });\n        });\n    });\n  }\n\n  recurse(dirpath);\n};\n\n/**\n * @description\n * Same as recurse, but it is synchronous\n * @example\n * file.recurseSync('path', function(filepath, filename) {});\n * file.recurseSync('path', ['*.js', 'path/**\\/*.html'], function(filepath, relative, filename) {});\n */\nexports.recurseSync = function(dirpath, filter, callback) {\n  if (util.isFunction(filter)) {\n    callback = filter;\n    filter = null;\n  }\n  var filterCb = fileMatch(filter);\n  var rootpath = dirpath;\n\n  function recurse(dirpath) {\n    fs.readdirSync(dirpath).forEach(function(filename) {\n      var filepath = path.join(dirpath, filename);\n      var stats = fs.statSync(filepath);\n      var relative = path.relative(rootpath, filepath);\n      var flag = filterCb(relative);\n\n      if (stats.isDirectory()) {\n        recurse(filepath);\n        if (flag) callback(filepath, relative);\n      } else {\n        if (flag) callback(filepath, relative, filename);\n      }\n    });\n  }\n\n  recurse(dirpath);\n};\n\n/**\n * @description\n * Remove folder and files in folder, but it's synchronous\n * @example\n * file.rmdirSync('path');\n */\nexports.rmdirSync = function(dirpath) {\n  exports.recurseSync(dirpath, function(filepath, relative, filename) {\n    // it is file, otherwise it's folder\n    if (filename) {\n      fs.unlinkSync(filepath);\n    } else {\n      fs.rmdirSync(filepath);\n    }\n  });\n\n  fs.rmdirSync(dirpath);\n};\n\n/**\n * @description\n * Copy dirpath to destpath, pass process callback for each file hanlder\n * if you want to change the dest filepath, process callback return { contents: '', filepath: ''}\n * otherwise only change contents\n * @example\n * file.copySync('path', 'dest');\n * file.copySync('src', 'dest/src');\n * file.copySync('path', 'dest', { process: function(contents, filepath) {} });\n * file.copySync('path', 'dest', { process: function(contents, filepath) {} }, noProcess: ['']);\n */\nexports.copySync = function(dirpath, destpath, options) {\n  options = util.extend({\n    encoding: 'utf8',\n    filter: null,\n    noProcess: ''\n  }, options || {});\n  var noProcessCb = fileMatch(options.noProcess);\n\n  // Make sure dest root\n  exports.mkdirSync(destpath);\n  exports.recurseSync(dirpath, options.filter, function(filepath, relative, filename) {\n    if (!filename) return;\n    var newpath = path.join(destpath, relative);\n    var opts = {\n      relative: relative\n    };\n\n    if (options.process && !noProcessCb(relative)) {\n      opts.encoding = options.encoding;\n      opts.process = options.process;\n    }\n\n    exports.copyFileSync(filepath, newpath, opts);\n  });\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}